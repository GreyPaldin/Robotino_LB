# Лабораторная работа по дисциплине "Интеллектуальное управление робототехническими комплексами и системами"

## Задача

&ensp; В рамках данной работы необходимо выполнить задачу по объездом робота препядствий и движение к цели, вокруг которой вращаются спутники по орбитам. Роботу заранее неизвестен характер движения препдядствий.

## Информация в GITHAB

&ensp; В данном репрезитории находится отчёт + рабочий код для выполнения задания, описанного во отчёте. Код написан на языке Python.
---

## Код

&ensp; Код разбит на два основных блока: main и navigation
---

### Блок main

&ensp; Этот файл реализует **основной цикл управления** роботом, интегрируя данные с датчиков, одометрию и нечёткий контроллер навигации для достижения целевой точки.


#### Назначение

1. Установка соединения с роботом.
2. Чтение данных с датчиков и одометрии.
3. Расчет скоростей через `NavigationController`.
4. Отправка управляющих команд.
5. Обработка аварийных ситуаций и остановка.


####  Глобальные настройки

```python
ROBOT_IP = '192.168.0.1'       # IP-адрес робота
CONTROL_PORT = 80              # Порт управления
TARGET_X = 0.5                 # Целевая координата X (м)
TARGET_Y = 0.5                 # Целевая координата Y (м)
TARGET_TOLERANCE = 0.02        # Допустимая погрешность (м)
MAX_VELOCITY = 0.20            # Макс. скорость (м/с)
```

####  Описание функций

##### `read_proximity_sensors()`
**Что делает**:  
Читает данные с массива из 9 инфракрасных датчиков расстояния робота через HTTP API.  
**Как работает**:  
1. Отправляет GET-запрос на `http://{ROBOT_IP}/data/distancesensorarray`.  
2. Проверяет код ответа (должен быть 200).  
3. Преобразует ответ в список из 9 значений.  
4. Фильтрует данные, возвращая 7 ключевых сенсоров:
   - Левые (`left_1`, `left_2`), передний (`front`), правые (`right_1`, `right_2`), задние (`rear_left`, `rear_right`).  
5. При ошибках выводит сообщение в консоль и возвращает `None`.
   
##### `CONNECT()`
**Что делает**:  
Устанавливает TCP-соединение с роботом для управления.  
**Как работает**:  
1. Создает сокет (`AF_INET` для IPv4, `SOCK_STREAM` для TCP).  
2. Подключается к `ROBOT_IP` на порт `CONTROL_PORT`.  
3. При успехе возвращает объект соединения.  
4. При ошибках (например, недоступен порт) выводит сообщение и возвращает `None`.

##### `fetch_odometry()`
**Что делает**:  
Получает текущие координаты и ориентацию робота через одометрию.  
**Как работает**:  
1. Отправляет GET-запрос на `http://{ROBOT_IP}/data/odometry`.  
2. Проверяет, что ответ содержит 7 значений (X, Y, угол и т.д.).  
3. Возвращает сырые данные в виде списка.  
4. При ошибках выводит сообщение и возвращает `None`.

##### `set_movement_velocity(vx, vy, omega)`
**Что делает**:  
Отправляет команды движения роботу в формате [vx, vy, omega].  
**Как работает**:  
1. Формирует POST-запрос к `http://{ROBOT_IP}/data/omnidrive`.  
2. Тело запроса – JSON-массив `[vx, vy, omega]`.  
3. Логирует отправленные скорости и ответ сервера.  
4. При ошибках (например, разрыв связи) выводит сообщение.

##### `calculate_position_offset(current_x, current_y)`
**Что делает**:  
Вычисляет отклонение робота от целевой точки `(TARGET_X, TARGET_Y)`.  
**Как работает**:  
1. Считает разницу:  
   - `delta_x = TARGET_X - current_x`  
   - `delta_y = TARGET_Y - current_y`  
2. Возвращает кортеж `(delta_x, delta_y)`.  
**Примечание**: Используется для определения направления движения.

##### `stop()`
**Что делает**:  
Немедленно останавливает робота.  
**Как работает**:  
Вызывает `set_movement_velocity(0, 0, 0)`, обнуляя все скорости.


##### `main_control_loop()`
**Что делает**:  
Главный цикл управления роботом.  
**Как работает**:  
1. **Инициализация**:  
   - Создает экземпляр `NavigationController`.  
   - Устанавливает соединение (`CONNECT()`).  

2. **Калибровка**:  
   - Получает начальные координаты (`odom_init`).  
   - Рассчитывает относительные координаты (`base_x`, `base_y`).  

3. **Цикл управления**:  
   - **Шаг 1**: Чтение текущих данных (`fetch_odometry()`).  
   - **Шаг 2**: Расчет отклонения от цели (`calculate_position_offset()`).  
   - **Шаг 3**: Чтение датчиков (`read_proximity_sensors()`).  
   - **Шаг 4**: Вычисление скоростей через `NavigationController.calculate_velocity()`.  
   - **Шаг 5**: Проверка достижения цели (`math.hypot(delta_x, delta_y) <= TARGET_TOLERANCE`).  
   - **Шаг 6**: Ограничение скоростей (`MAX_VELOCITY`) и отправка команд.  
   - **Шаг 7**: Пауза 50 мс (`time.sleep(0.05`).  

--- 

### Блок navigation
